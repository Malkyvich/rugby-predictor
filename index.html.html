</div>
                            </div>
                        </div>
                    `;
                }).join('');

                return `
                    <div class="mb-6">
                        <h4 class="font-bold text-lg mb-3 text-primary">${round} Results</h4>
                        <div class="space-y-2">${weekHtml}</div>
                    </div>
                `;
            }).join('');

            const content = `
                <div class="mb-8">
                    <h3 class="text-xl font-bold mb-4">üèÜ Season Championship</h3>
                    <div class="space-y-3">${seasonLeaderboardHtml}</div>
                </div>
                ${weeklyResultsHtml ? `<div><h3 class="text-xl font-bold mb-4">üìÖ Weekly Results</h3>${weeklyResultsHtml}</div>` : ''}
            `;

            document.getElementById('leaderboard-content').innerHTML = content || '<p class="text-center py-8 text-gray-500">No results yet. Enter some results to see the leaderboard!</p>';
        }

        function calculatePoints(prediction, actual) {
            if (!prediction || !actual) return 0;
            const predHome = parseInt(prediction.homeScore);
            const predAway = parseInt(prediction.awayScore);
            const actualHome = parseInt(actual.homeScore);
            const actualAway = parseInt(actual.awayScore);

            if (predHome === actualHome && predAway === actualAway) return 5;

            const predResult = predHome > predAway ? 'home' : (predHome < predAway ? 'away' : 'draw');
            const actualResult = actualHome > actualAway ? 'home' : (actualHome < actualAway ? 'away' : 'draw');

            if (predResult === actualResult) {
                const predMargin = Math.abs(predHome - predAway);
                const actualMargin = Math.abs(actualHome - actualAway);
                const marginDiff = Math.abs(predMargin - actualMargin);
                if (marginDiff <= 3) return 3;
                return 1;
            }
            return 0;
        }

        function calculateAccuracy(prediction, actual) {
            if (!prediction || !actual) return null;
            const predHome = parseInt(prediction.homeScore);
            const predAway = parseInt(prediction.awayScore);
            const actualHome = parseInt(actual.homeScore);
            const actualAway = parseInt(actual.awayScore);

            const predResult = predHome > predAway ? 'home' : (predHome < predAway ? 'away' : 'draw');
            const actualResult = actualHome > actualAway ? 'home' : (actualHome < actualAway ? 'away' : 'draw');

            if (predResult !== actualResult) {
                return -Math.abs(Math.abs(predHome - predAway) - Math.abs(actualHome - actualAway));
            }

            const predMargin = Math.abs(predHome - predAway);
            const actualMargin = Math.abs(actualHome - actualAway);
            return Math.abs(predMargin - actualMargin);
        }

        function calculateWeeklyRankings() {
            const weeklyResults = {};
            const seasonTotals = {};

            Object.keys(playerNames).forEach(playerId => {
                seasonTotals[playerId] = {
                    name: playerNames[playerId],
                    seasonPoints: 0,
                    weeksWon: 0,
                    weeksSecond: 0,
                    weeksThird: 0
                };
            });

            const fixturesByRound = {};
            fixtures.forEach(fixture => {
                if (fixture.completed && results[fixture.id]) {
                    const round = fixture.round || 'Other';
                    if (!fixturesByRound[round]) fixturesByRound[round] = [];
                    fixturesByRound[round].push(fixture);
                }
            });

            Object.keys(fixturesByRound).forEach(round => {
                const roundFixtures = fixturesByRound[round];
                const weeklyStats = {};

                Object.keys(playerNames).forEach(playerId => {
                    weeklyStats[playerId] = {
                        name: playerNames[playerId],
                        weeklyPoints: 0,
                        predictions: 0,
                        accuracyScores: []
                    };
                });

                roundFixtures.forEach(fixture => {
                    Object.keys(predictions).forEach(playerId => {
                        const prediction = predictions[playerId].submitted[fixture.id];
                        if (prediction) {
                            weeklyStats[playerId].predictions++;
                            weeklyStats[playerId].weeklyPoints += calculatePoints(prediction, results[fixture.id]);
                            
                            const accuracy = calculateAccuracy(prediction, results[fixture.id]);
                            if (accuracy !== null) {
                                weeklyStats[playerId].accuracyScores.push(accuracy);
                            }
                        }
                    });
                });

                Object.keys(weeklyStats).forEach(playerId => {
                    const stats = weeklyStats[playerId];
                    if (stats.accuracyScores.length > 0) {
                        stats.averageAccuracy = stats.accuracyScores.reduce((sum, acc) => sum + acc, 0) / stats.accuracyScores.length;
                    } else {
                        stats.averageAccuracy = 999;
                    }
                });

                const weeklyRanking = Object.values(weeklyStats)
                    .filter(stats => stats.predictions > 0)
                    .sort((a, b) => {
                        if (b.weeklyPoints === a.weeklyPoints) {
                            return a.averageAccuracy - b.averageAccuracy;
                        }
                        return b.weeklyPoints - a.weeklyPoints;
                    });

                weeklyRanking.forEach((player, index) => {
                    const playerId = Object.keys(playerNames).find(id => playerNames[id] === player.name);
                    const position = index + 1;
                    
                    let seasonPoints = 0;
                    if (position === 1) {
                        seasonPoints = 3;
                        seasonTotals[playerId].weeksWon++;
                    } else if (position === 2) {
                        seasonPoints = 2;
                        seasonTotals[playerId].weeksSecond++;
                    } else if (position === 3) {
                        seasonPoints = 1;
                        seasonTotals[playerId].weeksThird++;
                    }

                    seasonTotals[playerId].seasonPoints += seasonPoints;
                });

                weeklyResults[round] = weeklyRanking;
            });

            return { weeklyResults, seasonTotals };
        }

        function addFixture() {
            const html = teams.map(t => `<option value="${t}">${t}</option>`).join('');
            document.getElementById('home-team').innerHTML = html;
            document.getElementById('away-team').innerHTML = html;
            document.getElementById('fixture-modal').classList.remove('hidden');
            document.getElementById('fixture-modal').classList.add('flex');
        }

        function closeFixtureModal() {
            document.getElementById('fixture-modal').classList.add('hidden');
        }

        function saveFixture() {
            const home = document.getElementById('home-team').value;
            const away = document.getElementById('away-team').value;
            const date = document.getElementById('match-date').value;
            const round = document.getElementById('match-round').value || 'Other';
            
            if (home === away) {
                showToast('‚ö†Ô∏è Teams must be different', 'error');
                return;
            }
            
            fixtures.push({
                id: Date.now(),
                homeTeam: home,
                awayTeam: away,
                date,
                round,
                completed: false
            });
            
            saveToStorage();
            closeFixtureModal();
            updateFixturesView();
            showToast('‚úÖ Fixture added!', 'success');
        }

        function removeFixture(id) {
            if (confirm('Remove this fixture?')) {
                fixtures = fixtures.filter(f => f.id !== id);
                Object.keys(predictions).forEach(p => {
                    delete predictions[p].submitted[id];
                    delete predictions[p].pending[id];
                });
                delete results[id];
                saveToStorage();
                updateFixturesView();
                showToast('‚úÖ Fixture removed', 'success');
            }
        }

        function saveResult(id) {
            const home = document.getElementById(`result-home-${id}`).value;
            const away = document.getElementById(`result-away-${id}`).value;
            
            if (!home || !away) {
                showToast('‚ö†Ô∏è Enter both scores', 'error');
                return;
            }
            
            results[id] = { homeScore: parseInt(home), awayScore: parseInt(away) };
            const fixture = fixtures.find(f => f.id === id);
            if (fixture) fixture.completed = true;
            
            saveToStorage();
            updateResultsView();
            showToast('‚úÖ Result saved!', 'success');
        }

        function resetAllData() {
            if (confirm('Reset all data?')) {
                fixtures = [];
                predictions = {
                    player1: { submitted: {}, pending: {} },
                    player2: { submitted: {}, pending: {} },
                    player3: { submitted: {}, pending: {} }
                };
                results = {};
                saveToStorage();
                showTab('fixtures');
                showToast('‚úÖ Data reset', 'success');
            }
        }

        function reloadRound1Data() {
            if (confirm('This will reload Round 1 fixtures, predictions, and results. Any existing Round 1 data will be overwritten. Continue?')) {
                fixtures = fixtures.filter(f => f.round !== 'Round 1');
                
                fixtures.unshift(
                    { id: 1, homeTeam: 'Northampton', awayTeam: 'Exeter', date: '2025-09-20', round: 'Round 1', completed: true },
                    { id: 2, homeTeam: 'Sale Sharks', awayTeam: 'Bath', date: '2025-09-20', round: 'Round 1', completed: true },
                    { id: 3, homeTeam: 'Saracens', awayTeam: 'Gloucester', date: '2025-09-20', round: 'Round 1', completed: true },
                    { id: 4, homeTeam: 'Leicester Tigers', awayTeam: 'Newcastle Red Bulls', date: '2025-09-21', round: 'Round 1', completed: true },
                    { id: 5, homeTeam: 'Bristol Bears', awayTeam: 'Harlequins', date: '2025-09-21', round: 'Round 1', completed: true }
                );

                results[1] = { homeScore: 33, awayScore: 33 };
                results[2] = { homeScore: 27, awayScore: 10 };
                results[3] = { homeScore: 17, awayScore: 39 };
                results[4] = { homeScore: 42, awayScore: 24 };
                results[5] = { homeScore: 31, awayScore: 47 };

                predictions.player2.submitted[1] = { homeScore: 32, awayScore: 16 };
                predictions.player2.submitted[2] = { homeScore: 32, awayScore: 25 };
                predictions.player2.submitted[3] = { homeScore: 15, awayScore: 33 };
                predictions.player2.submitted[4] = { homeScore: 32, awayScore: 25 };
                predictions.player2.submitted[5] = { homeScore: 10, awayScore: 25 };

                predictions.player1.submitted[1] = { homeScore: 33, awayScore: 22 };
                predictions.player1.submitted[2] = { homeScore: 29, awayScore: 12 };
                predictions.player1.submitted[3] = { homeScore: 11, awayScore: 27 };
                predictions.player1.submitted[4] = { homeScore: 26, awayScore: 22 };
                predictions.player1.submitted[5] = { homeScore: 20, awayScore: 26 };

                predictions.player3.submitted[1] = { homeScore: 26, awayScore: 30 };
                predictions.player3.submitted[2] = { homeScore: 30, awayScore: 26 };
                predictions.player3.submitted[3] = { homeScore: 26, awayScore: 30 };

                saveToStorage();
                updateFixturesView();
                updateLeaderboard();
                showToast('‚úÖ Round 1 data reloaded!', 'success');
            }
        }

        function exportData() {
            const dataToExport = {
                fixtures,
                predictions,
                results,
                playerNames,
                exportDate: new Date().toISOString(),
                version: '1.0'
            };
            
            const dataStr = JSON.stringify(dataToExport, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `rugby-predictor-backup-${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            showToast('‚úÖ Data exported successfully!', 'success');
        }

        function importData() {
            document.getElementById('import-file-input').click();
        }

        function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (!importedData.fixtures || !importedData.predictions || !importedData.results) {
                        showToast('‚ùå Invalid data file', 'error');
                        return;
                    }
                    
                    if (confirm('This will replace all current data with the imported data. Continue?')) {
                        fixtures = importedData.fixtures;
                        predictions = importedData.predictions;
                        results = importedData.results;
                        playerNames = importedData.playerNames || playerNames;
                        
                        saveToStorage();
                        updateFixturesView();
                        updatePredictionsView();
                        updateResultsView();
                        updateLeaderboard();
                        
                        showToast('‚úÖ Data imported successfully!', 'success');
                    }
                } catch (error) {
                    showToast('‚ùå Error reading file: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
            
            event.target.value = '';
        }

        function showToast(msg, type) {
            const toast = document.createElement('div');
            toast.className = `toast ${type === 'success' ? 'bg-green-500' : 'bg-red-500'} text-white px-6 py-3 rounded-lg shadow-lg`;
            toast.textContent = msg;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // FIREBASE AUTO-CONNECT - No setup required!
        function initializeFirebase() {
            const config = {
                apiKey: "AIzaSyDOTBQ7Ap-ZDAkp0F08QxlFZP4MnfG760g",
                authDomain: "rugby-predictor-680fd.firebaseapp.com",
                databaseURL: "https://rugby-predictor-680fd-default-rtdb.europe-west1.firebasedatabase.app",
                projectId: "rugby-predictor-680fd",
                storageBucket: "rugby-predictor-680fd.firebasestorage.app",
                messagingSenderId: "211386280151",
                appId: "1:211386280151:web:6863351c2a574609db6892"
            };
            
            try {
                firebase.initializeApp(config);
                database = firebase.database();
                dataRef = database.ref('rugbyData');
                
                dataRef.on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        fixtures = data.fixtures || fixtures;
                        predictions = data.predictions || predictions;
                        results = data.results || results;
                        playerNames = data.playerNames || playerNames;
                        
                        const currentTab = document.querySelector('.tab-button.border-primary');
                        if (currentTab) {
                            const tabName = currentTab.id.replace('tab-', '');
                            if (tabName === 'predictions') updatePredictionsView();
                            if (tabName === 'fixtures') updateFixturesView();
                            if (tabName === 'results') updateResultsView();
                            if (tabName === 'leaderboard') updateLeaderboard();
                        }
                    }
                });
                
                firebaseInitialized = true;
                updateFirebaseStatus('‚úÖ Connected - Live sync active', 'text-green-600');
                
            } catch (error) {
                console.error('Firebase init error:', error);
                updateFirebaseStatus('‚ùå Connection failed - Using local storage', 'text-red-500');
            }
        }

        function updateFirebaseStatus(message, colorClass) {
            const statusEl = document.getElementById('firebase-status');
            if (statusEl) {
                statusEl.innerHTML = `<span class="${colorClass}">${message}</span>`;
            }
        }

        document.getElementById('player-select').addEventListener('change', updatePredictionsView);

        if (!loadFromStorage()) {
            initializeSampleData();
        }
        
        // Auto-connect to Firebase
        initializeFirebase();
        
        showTab('leaderboard');
    </script>
</body>
</html>
